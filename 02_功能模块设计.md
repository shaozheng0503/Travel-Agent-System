# æ—…æ¸¸AgentåŠŸèƒ½æ¨¡å—è®¾è®¡

## ğŸ¤– AIå¯¹è¯æ¨¡å—

### æ¨¡å—æ¦‚è¿°
AIå¯¹è¯æ¨¡å—æ˜¯æ—…æ¸¸Agentçš„æ ¸å¿ƒï¼Œè´Ÿè´£ç†è§£ç”¨æˆ·æ„å›¾ã€ç»´æŠ¤å¯¹è¯ä¸Šä¸‹æ–‡ã€ç”Ÿæˆæ™ºèƒ½å›å¤ã€‚

### æ ¸å¿ƒåŠŸèƒ½

#### 1. æ„å›¾è¯†åˆ«ç³»ç»Ÿ
```typescript
enum IntentType {
  PLAN_TRIP = 'plan_trip',           // è§„åˆ’æ—…è¡Œ
  SEARCH_HOTEL = 'search_hotel',     // æœç´¢é…’åº—
  CHECK_WEATHER = 'check_weather',   // æŸ¥è¯¢å¤©æ°”
  CALCULATE_BUDGET = 'calculate_budget', // è®¡ç®—é¢„ç®—
  RECOMMEND_ATTRACTION = 'recommend_attraction', // æ¨èæ™¯ç‚¹
  BOOK_TICKET = 'book_ticket',       // è®¢ç¥¨
  GET_DIRECTION = 'get_direction',   // è·å–è·¯çº¿
  GENERAL_INQUIRY = 'general_inquiry' // ä¸€èˆ¬å’¨è¯¢
}

class IntentRecognizer {
  private patterns: Map<IntentType, RegExp[]> = new Map([
    [IntentType.PLAN_TRIP, [
      /æˆ‘æƒ³å»(.+)æ—…æ¸¸/,
      /å¸®æˆ‘è§„åˆ’(.+)è¡Œç¨‹/,
      /è®¡åˆ’(.+)æ—…è¡Œ/
    ]],
    [IntentType.SEARCH_HOTEL, [
      /æ‰¾(.+)é…’åº—/,
      /æ¨è(.+)ä½å®¿/,
      /è®¢(.+)æˆ¿é—´/
    ]],
    [IntentType.CHECK_WEATHER, [
      /(.+)å¤©æ°”/,
      /(.+)æ°”æ¸©/,
      /(.+)ä¸‹é›¨/
    ]]
  ]);

  recognizeIntent(message: string): IntentType {
    for (const [intent, patterns] of this.patterns) {
      for (const pattern of patterns) {
        if (pattern.test(message)) {
          return intent;
        }
      }
    }
    return IntentType.GENERAL_INQUIRY;
  }
}
```

#### 2. å®ä½“æå–å™¨
```typescript
interface Entity {
  type: EntityType;
  value: string;
  confidence: number;
  position: { start: number; end: number };
}

enum EntityType {
  LOCATION = 'location',     // åœ°ç‚¹
  DATE = 'date',            // æ—¥æœŸ
  DURATION = 'duration',    // æ—¶é•¿
  BUDGET = 'budget',        // é¢„ç®—
  PEOPLE = 'people',        // äººæ•°
  TRANSPORT = 'transport'   // äº¤é€šæ–¹å¼
}

class EntityExtractor {
  private extractors: Map<EntityType, RegExp[]> = new Map([
    [EntityType.LOCATION, [
      /(åŒ—äº¬|ä¸Šæµ·|å¹¿å·|æ·±åœ³|æ­å·|æˆéƒ½|è¥¿å®‰|å—äº¬|æ­¦æ±‰|é‡åº†|è‹å·|é’å²›|å¤§è¿|å¦é—¨|ä¸‰äºš)/g
    ]],
    [EntityType.DATE, [
      /(\d{4}å¹´\d{1,2}æœˆ\d{1,2}æ—¥)/g,
      /(\d{1,2}æœˆ\d{1,2}æ—¥)/g,
      /(æ˜å¤©|åå¤©|ä¸‹å‘¨|ä¸‹ä¸ªæœˆ)/g
    ]],
    [EntityType.DURATION, [
      /(\d+å¤©|\d+æ—¥)/g,
      /(\d+ä¸ªæ˜ŸæœŸ|\d+å‘¨)/g
    ]],
    [EntityType.BUDGET, [
      /(\d+å…ƒ|\d+ä¸‡)/g,
      /é¢„ç®—(\d+)/g
    ]]
  ]);

  extractEntities(message: string): Entity[] {
    const entities: Entity[] = [];
    
    for (const [type, patterns] of this.extractors) {
      for (const pattern of patterns) {
        const matches = message.matchAll(pattern);
        for (const match of matches) {
          entities.push({
            type,
            value: match[1],
            confidence: 0.9,
            position: { start: match.index!, end: match.index! + match[0].length }
          });
        }
      }
    }
    
    return entities;
  }
}
```

#### 3. ä¸Šä¸‹æ–‡ç®¡ç†å™¨
```typescript
interface ConversationContext {
  userId: string;
  sessionId: string;
  messages: Message[];
  currentIntent: IntentType;
  extractedEntities: Entity[];
  userPreferences: UserPreferences;
  planningStage: PlanningStage;
  timestamp: number;
}

interface Message {
  role: 'user' | 'assistant';
  content: string;
  timestamp: number;
  intent?: IntentType;
  entities?: Entity[];
}

class ContextManager {
  private contexts: Map<string, ConversationContext> = new Map();
  private maxContextLength = 20;

  addMessage(userId: string, message: Message): void {
    const context = this.getOrCreateContext(userId);
    context.messages.push(message);
    
    // ä¿æŒä¸Šä¸‹æ–‡é•¿åº¦
    if (context.messages.length > this.maxContextLength) {
      context.messages = context.messages.slice(-this.maxContextLength);
    }
    
    context.timestamp = Date.now();
  }

  getContext(userId: string): ConversationContext | null {
    return this.contexts.get(userId) || null;
  }

  updatePlanningStage(userId: string, stage: PlanningStage): void {
    const context = this.contexts.get(userId);
    if (context) {
      context.planningStage = stage;
    }
  }

  private getOrCreateContext(userId: string): ConversationContext {
    if (!this.contexts.has(userId)) {
      this.contexts.set(userId, {
        userId,
        sessionId: this.generateSessionId(),
        messages: [],
        currentIntent: IntentType.GENERAL_INQUIRY,
        extractedEntities: [],
        userPreferences: {},
        planningStage: PlanningStage.INITIAL,
        timestamp: Date.now()
      });
    }
    return this.contexts.get(userId)!;
  }
}
```

#### 4. AIå“åº”ç”Ÿæˆå™¨
```typescript
class AIResponseGenerator {
  private openai: OpenAI;

  constructor(apiKey: string) {
    this.openai = new OpenAI({ apiKey });
  }

  async generateResponse(
    intent: IntentType,
    entities: Entity[],
    context: ConversationContext
  ): Promise<string> {
    const prompt = this.buildPrompt(intent, entities, context);
    
    try {
      const completion = await this.openai.chat.completions.create({
        model: "gpt-4",
        messages: [
          {
            role: "system",
            content: "ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„æ—…æ¸¸è§„åˆ’åŠ©æ‰‹ï¼Œèƒ½å¤Ÿå¸®åŠ©ç”¨æˆ·è§„åˆ’æ—…è¡Œã€æ¨èæ™¯ç‚¹ã€æŸ¥è¯¢ä¿¡æ¯ç­‰ã€‚"
          },
          {
            role: "user",
            content: prompt
          }
        ],
        max_tokens: 500,
        temperature: 0.7
      });

      return completion.choices[0].message.content || "æŠ±æ­‰ï¼Œæˆ‘ç°åœ¨æ— æ³•å›ç­”æ‚¨çš„é—®é¢˜ã€‚";
    } catch (error) {
      console.error('AIå“åº”ç”Ÿæˆå¤±è´¥:', error);
      return this.getFallbackResponse(intent);
    }
  }

  private buildPrompt(intent: IntentType, entities: Entity[], context: ConversationContext): string {
    const entityInfo = entities.map(e => `${e.type}: ${e.value}`).join(', ');
    const recentMessages = context.messages.slice(-5).map(m => `${m.role}: ${m.content}`).join('\n');
    
    return `
æ„å›¾: ${intent}
å®ä½“: ${entityInfo}
è§„åˆ’é˜¶æ®µ: ${context.planningStage}
æœ€è¿‘å¯¹è¯:
${recentMessages}

è¯·æ ¹æ®ä»¥ä¸Šä¿¡æ¯ç”Ÿæˆåˆé€‚çš„å›å¤ã€‚
    `.trim();
  }
}
```

## ğŸ—ºï¸ è·¯çº¿è§„åˆ’æ¨¡å—

### æ¨¡å—æ¦‚è¿°
åŸºäºé«˜å¾·åœ°å›¾APIçš„æ™ºèƒ½è·¯çº¿è§„åˆ’æ¨¡å—ï¼Œæ”¯æŒå¤šç§äº¤é€šæ–¹å¼ã€å¤šç‚¹è·¯çº¿ä¼˜åŒ–ã€å®æ—¶è·¯å†µç­‰åŠŸèƒ½ã€‚

### æ ¸å¿ƒåŠŸèƒ½

#### 1. åŸºç¡€è·¯çº¿è§„åˆ’
```typescript
interface Location {
  lat: number;
  lng: number;
  address?: string;
  name?: string;
}

interface Route {
  id: string;
  start: Location;
  end: Location;
  waypoints: Location[];
  distance: number; // ç±³
  duration: number; // ç§’
  steps: RouteStep[];
  trafficInfo?: TrafficInfo;
  cost?: number;
}

interface RouteStep {
  instruction: string;
  distance: number;
  duration: number;
  polyline: [number, number][];
  transportMode: TransportMode;
}

class RoutePlanner {
  private amap: AMap.Map;
  private driving: AMap.Driving;
  private walking: AMap.Walking;
  private transit: AMap.Transit;

  constructor(apiKey: string) {
    this.amap = new AMap.Map('map', { key: apiKey });
    this.driving = new AMap.Driving({ map: this.amap });
    this.walking = new AMap.Walking({ map: this.amap });
    this.transit = new AMap.Transit({ map: this.amap });
  }

  async planRoute(
    start: Location,
    end: Location,
    mode: TransportMode,
    waypoints: Location[] = []
  ): Promise<Route> {
    const planner = this.getPlanner(mode);
    
    return new Promise((resolve, reject) => {
      planner.search(
        this.formatLocation(start),
        this.formatLocation(end),
        (status: string, result: any) => {
          if (status === 'complete') {
            resolve(this.formatRouteResult(result, mode));
          } else {
            reject(new Error(`è·¯çº¿è§„åˆ’å¤±è´¥: ${status}`));
          }
        }
      );
    });
  }

  private getPlanner(mode: TransportMode): any {
    switch (mode) {
      case TransportMode.DRIVING:
        return this.driving;
      case TransportMode.WALKING:
        return this.walking;
      case TransportMode.TRANSIT:
        return this.transit;
      default:
        return this.driving;
    }
  }
}
```

#### 2. å¤šç‚¹è·¯çº¿ä¼˜åŒ–
```typescript
class MultiPointRouteOptimizer {
  async optimizeRoute(points: Location[], mode: TransportMode): Promise<Route[]> {
    // ä½¿ç”¨æ—…è¡Œå•†é—®é¢˜ç®—æ³•ä¼˜åŒ–è·¯çº¿
    const optimizedOrder = this.solveTSP(points);
    const routes: Route[] = [];
    
    for (let i = 0; i < optimizedOrder.length - 1; i++) {
      const route = await this.planRoute(
        optimizedOrder[i],
        optimizedOrder[i + 1],
        mode
      );
      routes.push(route);
    }
    
    return routes;
  }

  private solveTSP(points: Location[]): Location[] {
    // ç®€å•çš„è´ªå¿ƒç®—æ³•ï¼Œå®é™…é¡¹ç›®ä¸­å¯ä»¥ä½¿ç”¨æ›´å¤æ‚çš„ç®—æ³•
    const visited = new Set<number>();
    const result: Location[] = [points[0]];
    visited.add(0);
    
    while (visited.size < points.length) {
      let minDistance = Infinity;
      let nextIndex = -1;
      
      for (let i = 0; i < points.length; i++) {
        if (!visited.has(i)) {
          const distance = this.calculateDistance(
            result[result.length - 1],
            points[i]
          );
          if (distance < minDistance) {
            minDistance = distance;
            nextIndex = i;
          }
        }
      }
      
      if (nextIndex !== -1) {
        result.push(points[nextIndex]);
        visited.add(nextIndex);
      }
    }
    
    return result;
  }
}
```

#### 3. å®æ—¶è·¯å†µä¿¡æ¯
```typescript
interface TrafficInfo {
  congestion: 'smooth' | 'slow' | 'congested';
  delay: number; // å»¶è¿Ÿæ—¶é—´ï¼ˆç§’ï¼‰
  speed: number; // å¹³å‡é€Ÿåº¦ï¼ˆkm/hï¼‰
  description: string;
}

class TrafficMonitor {
  async getTrafficInfo(route: Route): Promise<TrafficInfo> {
    // è°ƒç”¨é«˜å¾·åœ°å›¾è·¯å†µAPI
    const response = await fetch(
      `https://restapi.amap.com/v3/traffic/status/rectangle?key=${this.apiKey}&level=4`
    );
    
    const data = await response.json();
    return this.parseTrafficData(data, route);
  }

  async getRealTimeTraffic(location: Location): Promise<TrafficInfo[]> {
    // è·å–æŒ‡å®šåŒºåŸŸçš„å®æ—¶è·¯å†µ
    const bounds = this.calculateBounds(location, 5000); // 5å…¬é‡ŒèŒƒå›´
    
    const response = await fetch(
      `https://restapi.amap.com/v3/traffic/status/rectangle?key=${this.apiKey}&level=4&rectangle=${bounds}`
    );
    
    const data = await response.json();
    return this.parseAreaTrafficData(data);
  }
}
```

## ğŸ¨ æ¨èç³»ç»Ÿæ¨¡å—

### æ¨¡å—æ¦‚è¿°
åŸºäºç”¨æˆ·åå¥½ã€å†å²è¡Œä¸ºã€ååŒè¿‡æ»¤ç­‰ç®—æ³•çš„æ™ºèƒ½æ¨èç³»ç»Ÿï¼Œä¸ºç”¨æˆ·æ¨èæ™¯ç‚¹ã€é…’åº—ã€é¤å…ç­‰ã€‚

### æ ¸å¿ƒåŠŸèƒ½

#### 1. ç”¨æˆ·ç”»åƒæ„å»º
```typescript
interface UserProfile {
  userId: string;
  preferences: {
    travelStyle: TravelStyle;
    budgetRange: BudgetRange;
    interests: Interest[];
    preferredDestinations: string[];
    preferredActivities: ActivityType[];
  };
  behavior: {
    searchHistory: SearchRecord[];
    clickHistory: ClickRecord[];
    bookingHistory: BookingRecord[];
    ratingHistory: RatingRecord[];
  };
  demographics: {
    age: number;
    gender: string;
    location: string;
    occupation: string;
  };
}

class UserProfileBuilder {
  async buildProfile(userId: string): Promise<UserProfile> {
    const [preferences, behavior, demographics] = await Promise.all([
      this.getUserPreferences(userId),
      this.getUserBehavior(userId),
      this.getUserDemographics(userId)
    ]);

    return {
      userId,
      preferences,
      behavior,
      demographics
    };
  }

  async updatePreferences(userId: string, newPreferences: Partial<UserPreferences>): Promise<void> {
    // æ›´æ–°ç”¨æˆ·åå¥½
    await this.userRepository.updatePreferences(userId, newPreferences);
    
    // é‡æ–°è®¡ç®—æ¨èæƒé‡
    await this.recalculateRecommendationWeights(userId);
  }
}
```

#### 2. æ™¯ç‚¹æ¨èç®—æ³•
```typescript
interface Attraction {
  id: string;
  name: string;
  location: Location;
  category: AttractionCategory;
  rating: number;
  price: number;
  openingHours: string;
  description: string;
  images: string[];
  tags: string[];
}

class AttractionRecommender {
  async recommendAttractions(
    location: string,
    userProfile: UserProfile,
    constraints: RecommendationConstraints
  ): Promise<Attraction[]> {
    // 1. åŸºäºå†…å®¹çš„è¿‡æ»¤
    const contentBased = await this.contentBasedFiltering(location, userProfile);
    
    // 2. ååŒè¿‡æ»¤
    const collaborative = await this.collaborativeFiltering(location, userProfile);
    
    // 3. æ··åˆæ¨è
    const hybrid = this.hybridRecommendation(contentBased, collaborative);
    
    // 4. åº”ç”¨çº¦æŸæ¡ä»¶
    const filtered = this.applyConstraints(hybrid, constraints);
    
    // 5. æ’åºå’Œè¿”å›
    return this.rankRecommendations(filtered, userProfile);
  }

  private async contentBasedFiltering(
    location: string,
    userProfile: UserProfile
  ): Promise<Attraction[]> {
    const attractions = await this.getAttractionsByLocation(location);
    
    return attractions.filter(attraction => {
      // åŸºäºç”¨æˆ·å…´è¶£åŒ¹é…
      const interestMatch = this.calculateInterestMatch(attraction, userProfile.preferences.interests);
      
      // åŸºäºé¢„ç®—åŒ¹é…
      const budgetMatch = attraction.price <= userProfile.preferences.budgetRange.max;
      
      // åŸºäºæ—…è¡Œé£æ ¼åŒ¹é…
      const styleMatch = this.calculateStyleMatch(attraction, userProfile.preferences.travelStyle);
      
      return interestMatch > 0.6 && budgetMatch && styleMatch > 0.5;
    });
  }

  private async collaborativeFiltering(
    location: string,
    userProfile: UserProfile
  ): Promise<Attraction[]> {
    // æ‰¾åˆ°ç›¸ä¼¼ç”¨æˆ·
    const similarUsers = await this.findSimilarUsers(userProfile);
    
    // è·å–ç›¸ä¼¼ç”¨æˆ·å–œæ¬¢çš„æ™¯ç‚¹
    const recommendations = new Map<string, number>();
    
    for (const similarUser of similarUsers) {
      const userRatings = await this.getUserRatings(similarUser.userId);
      const similarity = similarUser.similarity;
      
      for (const rating of userRatings) {
        if (rating.location === location && rating.rating >= 4) {
          const currentScore = recommendations.get(rating.attractionId) || 0;
          recommendations.set(rating.attractionId, currentScore + similarity * rating.rating);
        }
      }
    }
    
    // è·å–æ¨èæ™¯ç‚¹è¯¦æƒ…
    const attractionIds = Array.from(recommendations.keys())
      .sort((a, b) => recommendations.get(b)! - recommendations.get(a)!)
      .slice(0, 20);
    
    return await this.getAttractionsByIds(attractionIds);
  }
}
```

#### 3. é…’åº—æ¨èç®—æ³•
```typescript
interface Hotel {
  id: string;
  name: string;
  location: Location;
  stars: number;
  price: number;
  amenities: string[];
  rating: number;
  reviews: number;
  images: string[];
  description: string;
}

class HotelRecommender {
  async recommendHotels(
    location: string,
    dates: DateRange,
    budget: BudgetRange,
    userProfile: UserProfile
  ): Promise<Hotel[]> {
    // 1. è·å–å¯ç”¨é…’åº—
    const availableHotels = await this.getAvailableHotels(location, dates);
    
    // 2. é¢„ç®—è¿‡æ»¤
    const budgetFiltered = availableHotels.filter(
      hotel => hotel.price >= budget.min && hotel.price <= budget.max
    );
    
    // 3. ä¸ªæ€§åŒ–æ¨è
    const personalized = await this.personalizeRecommendations(budgetFiltered, userProfile);
    
    // 4. è¯„åˆ†æ’åº
    return this.rankHotels(personalized, userProfile);
  }

  private async personalizeRecommendations(
    hotels: Hotel[],
    userProfile: UserProfile
  ): Promise<Hotel[]> {
    return hotels.map(hotel => ({
      ...hotel,
      personalizedScore: this.calculatePersonalizedScore(hotel, userProfile)
    })).sort((a, b) => b.personalizedScore - a.personalizedScore);
  }

  private calculatePersonalizedScore(hotel: Hotel, userProfile: UserProfile): number {
    let score = hotel.rating;
    
    // åŸºäºç”¨æˆ·åå¥½çš„è°ƒæ•´
    if (userProfile.preferences.travelStyle === TravelStyle.LUXURY && hotel.stars >= 4) {
      score += 0.5;
    }
    
    if (userProfile.preferences.travelStyle === TravelStyle.BUDGET && hotel.price < 300) {
      score += 0.3;
    }
    
    // åŸºäºå†å²è¡Œä¸ºçš„è°ƒæ•´
    const userHistory = userProfile.behavior.bookingHistory;
    const similarHotels = userHistory.filter(booking => 
      Math.abs(booking.hotel.price - hotel.price) < 100
    );
    
    if (similarHotels.length > 0) {
      const avgRating = similarHotels.reduce((sum, booking) => sum + booking.rating, 0) / similarHotels.length;
      score += (avgRating - 3) * 0.2;
    }
    
    return score;
  }
}
```

## ğŸ’° é¢„ç®—ç®¡ç†æ¨¡å—

### æ¨¡å—æ¦‚è¿°
æ™ºèƒ½é¢„ç®—ç®¡ç†æ¨¡å—ï¼Œæä¾›è´¹ç”¨ä¼°ç®—ã€é¢„ç®—åˆ†æã€æˆæœ¬ä¼˜åŒ–å»ºè®®ç­‰åŠŸèƒ½ã€‚

### æ ¸å¿ƒåŠŸèƒ½

#### 1. è´¹ç”¨ä¼°ç®—å™¨
```typescript
interface CostEstimate {
  category: CostCategory;
  amount: number;
  currency: string;
  breakdown: CostBreakdown[];
  confidence: number;
}

interface CostBreakdown {
  item: string;
  amount: number;
  unit: string;
  quantity: number;
  notes?: string;
}

class CostEstimator {
  async estimateTransportationCost(
    route: Route,
    mode: TransportMode,
    passengers: number
  ): Promise<CostEstimate> {
    const baseCost = this.getBaseTransportCost(route, mode);
    const distanceMultiplier = this.getDistanceMultiplier(route.distance);
    const modeMultiplier = this.getModeMultiplier(mode);
    
    const totalCost = baseCost * distanceMultiplier * modeMultiplier * passengers;
    
    return {
      category: CostCategory.TRANSPORTATION,
      amount: totalCost,
      currency: 'CNY',
      breakdown: [
        {
          item: `${mode}è´¹ç”¨`,
          amount: totalCost,
          unit: 'å…ƒ',
          quantity: passengers,
          notes: `è·ç¦»: ${route.distance / 1000}km`
        }
      ],
      confidence: 0.85
    };
  }

  async estimateAccommodationCost(
    hotels: Hotel[],
    duration: number,
    guests: number
  ): Promise<CostEstimate> {
    const totalCost = hotels.reduce((sum, hotel) => {
      return sum + hotel.price * duration * Math.ceil(guests / 2);
    }, 0);
    
    return {
      category: CostCategory.ACCOMMODATION,
      amount: totalCost,
      currency: 'CNY',
      breakdown: hotels.map(hotel => ({
        item: hotel.name,
        amount: hotel.price * duration * Math.ceil(guests / 2),
        unit: 'å…ƒ',
        quantity: duration,
        notes: `${hotel.stars}æ˜Ÿçº§é…’åº—`
      })),
      confidence: 0.9
    };
  }

  async estimateFoodCost(
    duration: number,
    guests: number,
    preferences: FoodPreferences
  ): Promise<CostEstimate> {
    const dailyCost = this.getDailyFoodCost(preferences);
    const totalCost = dailyCost * duration * guests;
    
    return {
      category: CostCategory.FOOD,
      amount: totalCost,
      currency: 'CNY',
      breakdown: [
        {
          item: 'é¤é¥®è´¹ç”¨',
          amount: totalCost,
          unit: 'å…ƒ',
          quantity: duration * guests,
          notes: `æ¯äººæ¯å¤©${dailyCost}å…ƒ`
        }
      ],
      confidence: 0.8
    };
  }
}
```

#### 2. é¢„ç®—åˆ†æå™¨
```typescript
interface BudgetAnalysis {
  totalBudget: number;
  breakdown: CostBreakdown[];
  efficiency: BudgetEfficiency;
  recommendations: BudgetRecommendation[];
  riskLevel: RiskLevel;
}

interface BudgetEfficiency {
  score: number; // 0-100
  category: 'excellent' | 'good' | 'fair' | 'poor';
  factors: EfficiencyFactor[];
}

class BudgetAnalyzer {
  analyzeBudget(itinerary: Itinerary, userBudget: number): BudgetAnalysis {
    const totalCost = this.calculateTotalCost(itinerary);
    const efficiency = this.calculateEfficiency(totalCost, userBudget);
    const recommendations = this.generateRecommendations(itinerary, totalCost, userBudget);
    const riskLevel = this.assessRiskLevel(totalCost, userBudget);
    
    return {
      totalBudget: totalCost,
      breakdown: this.getCostBreakdown(itinerary),
      efficiency,
      recommendations,
      riskLevel
    };
  }

  private calculateEfficiency(totalCost: number, userBudget: number): BudgetEfficiency {
    const ratio = totalCost / userBudget;
    let score: number;
    let category: BudgetEfficiency['category'];
    
    if (ratio <= 0.8) {
      score = 90 + (0.8 - ratio) * 50;
      category = 'excellent';
    } else if (ratio <= 1.0) {
      score = 70 + (1.0 - ratio) * 100;
      category = 'good';
    } else if (ratio <= 1.2) {
      score = 50 + (1.2 - ratio) * 100;
      category = 'fair';
    } else {
      score = Math.max(0, 50 - (ratio - 1.2) * 100);
      category = 'poor';
    }
    
    return {
      score: Math.round(score),
      category,
      factors: this.identifyEfficiencyFactors(totalCost, userBudget)
    };
  }

  private generateRecommendations(
    itinerary: Itinerary,
    totalCost: number,
    userBudget: number
  ): BudgetRecommendation[] {
    const recommendations: BudgetRecommendation[] = [];
    
    if (totalCost > userBudget) {
      // è¶…é¢„ç®—å»ºè®®
      const overspend = totalCost - userBudget;
      
      if (itinerary.accommodation && itinerary.accommodation.cost > userBudget * 0.4) {
        recommendations.push({
          type: 'reduce_accommodation',
          description: `è€ƒè™‘é€‰æ‹©æ›´ç»æµçš„ä½å®¿ï¼Œå¯èŠ‚çœçº¦${Math.round(overspend * 0.3)}å…ƒ`,
          potentialSavings: overspend * 0.3,
          priority: 'high'
        });
      }
      
      if (itinerary.transportation && itinerary.transportation.cost > userBudget * 0.3) {
        recommendations.push({
          type: 'optimize_transport',
          description: `ä¼˜åŒ–äº¤é€šæ–¹å¼ï¼Œå¯èŠ‚çœçº¦${Math.round(overspend * 0.2)}å…ƒ`,
          potentialSavings: overspend * 0.2,
          priority: 'medium'
        });
      }
    } else {
      // é¢„ç®—å……è¶³å»ºè®®
      const remaining = userBudget - totalCost;
      
      if (remaining > userBudget * 0.2) {
        recommendations.push({
          type: 'upgrade_experience',
          description: `å¯ä»¥è€ƒè™‘å‡çº§ä½å®¿æˆ–å¢åŠ ç‰¹è‰²ä½“éªŒï¼Œé¢„ç®—å……è¶³`,
          potentialSavings: 0,
          priority: 'low'
        });
      }
    }
    
    return recommendations;
  }
}
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2024å¹´12æœˆ  
**ç»´æŠ¤è€…**: åŠŸèƒ½è®¾è®¡å›¢é˜Ÿ 