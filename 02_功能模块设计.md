# 旅游Agent功能模块设计

## 🤖 AI对话模块

### 模块概述
AI对话模块是旅游Agent的核心，负责理解用户意图、维护对话上下文、生成智能回复。

### 核心功能

#### 1. 意图识别系统
```typescript
enum IntentType {
  PLAN_TRIP = 'plan_trip',           // 规划旅行
  SEARCH_HOTEL = 'search_hotel',     // 搜索酒店
  CHECK_WEATHER = 'check_weather',   // 查询天气
  CALCULATE_BUDGET = 'calculate_budget', // 计算预算
  RECOMMEND_ATTRACTION = 'recommend_attraction', // 推荐景点
  BOOK_TICKET = 'book_ticket',       // 订票
  GET_DIRECTION = 'get_direction',   // 获取路线
  GENERAL_INQUIRY = 'general_inquiry' // 一般咨询
}

class IntentRecognizer {
  private patterns: Map<IntentType, RegExp[]> = new Map([
    [IntentType.PLAN_TRIP, [
      /我想去(.+)旅游/,
      /帮我规划(.+)行程/,
      /计划(.+)旅行/
    ]],
    [IntentType.SEARCH_HOTEL, [
      /找(.+)酒店/,
      /推荐(.+)住宿/,
      /订(.+)房间/
    ]],
    [IntentType.CHECK_WEATHER, [
      /(.+)天气/,
      /(.+)气温/,
      /(.+)下雨/
    ]]
  ]);

  recognizeIntent(message: string): IntentType {
    for (const [intent, patterns] of this.patterns) {
      for (const pattern of patterns) {
        if (pattern.test(message)) {
          return intent;
        }
      }
    }
    return IntentType.GENERAL_INQUIRY;
  }
}
```

#### 2. 实体提取器
```typescript
interface Entity {
  type: EntityType;
  value: string;
  confidence: number;
  position: { start: number; end: number };
}

enum EntityType {
  LOCATION = 'location',     // 地点
  DATE = 'date',            // 日期
  DURATION = 'duration',    // 时长
  BUDGET = 'budget',        // 预算
  PEOPLE = 'people',        // 人数
  TRANSPORT = 'transport'   // 交通方式
}

class EntityExtractor {
  private extractors: Map<EntityType, RegExp[]> = new Map([
    [EntityType.LOCATION, [
      /(北京|上海|广州|深圳|杭州|成都|西安|南京|武汉|重庆|苏州|青岛|大连|厦门|三亚)/g
    ]],
    [EntityType.DATE, [
      /(\d{4}年\d{1,2}月\d{1,2}日)/g,
      /(\d{1,2}月\d{1,2}日)/g,
      /(明天|后天|下周|下个月)/g
    ]],
    [EntityType.DURATION, [
      /(\d+天|\d+日)/g,
      /(\d+个星期|\d+周)/g
    ]],
    [EntityType.BUDGET, [
      /(\d+元|\d+万)/g,
      /预算(\d+)/g
    ]]
  ]);

  extractEntities(message: string): Entity[] {
    const entities: Entity[] = [];
    
    for (const [type, patterns] of this.extractors) {
      for (const pattern of patterns) {
        const matches = message.matchAll(pattern);
        for (const match of matches) {
          entities.push({
            type,
            value: match[1],
            confidence: 0.9,
            position: { start: match.index!, end: match.index! + match[0].length }
          });
        }
      }
    }
    
    return entities;
  }
}
```

#### 3. 上下文管理器
```typescript
interface ConversationContext {
  userId: string;
  sessionId: string;
  messages: Message[];
  currentIntent: IntentType;
  extractedEntities: Entity[];
  userPreferences: UserPreferences;
  planningStage: PlanningStage;
  timestamp: number;
}

interface Message {
  role: 'user' | 'assistant';
  content: string;
  timestamp: number;
  intent?: IntentType;
  entities?: Entity[];
}

class ContextManager {
  private contexts: Map<string, ConversationContext> = new Map();
  private maxContextLength = 20;

  addMessage(userId: string, message: Message): void {
    const context = this.getOrCreateContext(userId);
    context.messages.push(message);
    
    // 保持上下文长度
    if (context.messages.length > this.maxContextLength) {
      context.messages = context.messages.slice(-this.maxContextLength);
    }
    
    context.timestamp = Date.now();
  }

  getContext(userId: string): ConversationContext | null {
    return this.contexts.get(userId) || null;
  }

  updatePlanningStage(userId: string, stage: PlanningStage): void {
    const context = this.contexts.get(userId);
    if (context) {
      context.planningStage = stage;
    }
  }

  private getOrCreateContext(userId: string): ConversationContext {
    if (!this.contexts.has(userId)) {
      this.contexts.set(userId, {
        userId,
        sessionId: this.generateSessionId(),
        messages: [],
        currentIntent: IntentType.GENERAL_INQUIRY,
        extractedEntities: [],
        userPreferences: {},
        planningStage: PlanningStage.INITIAL,
        timestamp: Date.now()
      });
    }
    return this.contexts.get(userId)!;
  }
}
```

#### 4. AI响应生成器
```typescript
class AIResponseGenerator {
  private openai: OpenAI;

  constructor(apiKey: string) {
    this.openai = new OpenAI({ apiKey });
  }

  async generateResponse(
    intent: IntentType,
    entities: Entity[],
    context: ConversationContext
  ): Promise<string> {
    const prompt = this.buildPrompt(intent, entities, context);
    
    try {
      const completion = await this.openai.chat.completions.create({
        model: "gpt-4",
        messages: [
          {
            role: "system",
            content: "你是一个专业的旅游规划助手，能够帮助用户规划旅行、推荐景点、查询信息等。"
          },
          {
            role: "user",
            content: prompt
          }
        ],
        max_tokens: 500,
        temperature: 0.7
      });

      return completion.choices[0].message.content || "抱歉，我现在无法回答您的问题。";
    } catch (error) {
      console.error('AI响应生成失败:', error);
      return this.getFallbackResponse(intent);
    }
  }

  private buildPrompt(intent: IntentType, entities: Entity[], context: ConversationContext): string {
    const entityInfo = entities.map(e => `${e.type}: ${e.value}`).join(', ');
    const recentMessages = context.messages.slice(-5).map(m => `${m.role}: ${m.content}`).join('\n');
    
    return `
意图: ${intent}
实体: ${entityInfo}
规划阶段: ${context.planningStage}
最近对话:
${recentMessages}

请根据以上信息生成合适的回复。
    `.trim();
  }
}
```

## 🗺️ 路线规划模块

### 模块概述
基于高德地图API的智能路线规划模块，支持多种交通方式、多点路线优化、实时路况等功能。

### 核心功能

#### 1. 基础路线规划
```typescript
interface Location {
  lat: number;
  lng: number;
  address?: string;
  name?: string;
}

interface Route {
  id: string;
  start: Location;
  end: Location;
  waypoints: Location[];
  distance: number; // 米
  duration: number; // 秒
  steps: RouteStep[];
  trafficInfo?: TrafficInfo;
  cost?: number;
}

interface RouteStep {
  instruction: string;
  distance: number;
  duration: number;
  polyline: [number, number][];
  transportMode: TransportMode;
}

class RoutePlanner {
  private amap: AMap.Map;
  private driving: AMap.Driving;
  private walking: AMap.Walking;
  private transit: AMap.Transit;

  constructor(apiKey: string) {
    this.amap = new AMap.Map('map', { key: apiKey });
    this.driving = new AMap.Driving({ map: this.amap });
    this.walking = new AMap.Walking({ map: this.amap });
    this.transit = new AMap.Transit({ map: this.amap });
  }

  async planRoute(
    start: Location,
    end: Location,
    mode: TransportMode,
    waypoints: Location[] = []
  ): Promise<Route> {
    const planner = this.getPlanner(mode);
    
    return new Promise((resolve, reject) => {
      planner.search(
        this.formatLocation(start),
        this.formatLocation(end),
        (status: string, result: any) => {
          if (status === 'complete') {
            resolve(this.formatRouteResult(result, mode));
          } else {
            reject(new Error(`路线规划失败: ${status}`));
          }
        }
      );
    });
  }

  private getPlanner(mode: TransportMode): any {
    switch (mode) {
      case TransportMode.DRIVING:
        return this.driving;
      case TransportMode.WALKING:
        return this.walking;
      case TransportMode.TRANSIT:
        return this.transit;
      default:
        return this.driving;
    }
  }
}
```

#### 2. 多点路线优化
```typescript
class MultiPointRouteOptimizer {
  async optimizeRoute(points: Location[], mode: TransportMode): Promise<Route[]> {
    // 使用旅行商问题算法优化路线
    const optimizedOrder = this.solveTSP(points);
    const routes: Route[] = [];
    
    for (let i = 0; i < optimizedOrder.length - 1; i++) {
      const route = await this.planRoute(
        optimizedOrder[i],
        optimizedOrder[i + 1],
        mode
      );
      routes.push(route);
    }
    
    return routes;
  }

  private solveTSP(points: Location[]): Location[] {
    // 简单的贪心算法，实际项目中可以使用更复杂的算法
    const visited = new Set<number>();
    const result: Location[] = [points[0]];
    visited.add(0);
    
    while (visited.size < points.length) {
      let minDistance = Infinity;
      let nextIndex = -1;
      
      for (let i = 0; i < points.length; i++) {
        if (!visited.has(i)) {
          const distance = this.calculateDistance(
            result[result.length - 1],
            points[i]
          );
          if (distance < minDistance) {
            minDistance = distance;
            nextIndex = i;
          }
        }
      }
      
      if (nextIndex !== -1) {
        result.push(points[nextIndex]);
        visited.add(nextIndex);
      }
    }
    
    return result;
  }
}
```

#### 3. 实时路况信息
```typescript
interface TrafficInfo {
  congestion: 'smooth' | 'slow' | 'congested';
  delay: number; // 延迟时间（秒）
  speed: number; // 平均速度（km/h）
  description: string;
}

class TrafficMonitor {
  async getTrafficInfo(route: Route): Promise<TrafficInfo> {
    // 调用高德地图路况API
    const response = await fetch(
      `https://restapi.amap.com/v3/traffic/status/rectangle?key=${this.apiKey}&level=4`
    );
    
    const data = await response.json();
    return this.parseTrafficData(data, route);
  }

  async getRealTimeTraffic(location: Location): Promise<TrafficInfo[]> {
    // 获取指定区域的实时路况
    const bounds = this.calculateBounds(location, 5000); // 5公里范围
    
    const response = await fetch(
      `https://restapi.amap.com/v3/traffic/status/rectangle?key=${this.apiKey}&level=4&rectangle=${bounds}`
    );
    
    const data = await response.json();
    return this.parseAreaTrafficData(data);
  }
}
```

## 🏨 推荐系统模块

### 模块概述
基于用户偏好、历史行为、协同过滤等算法的智能推荐系统，为用户推荐景点、酒店、餐厅等。

### 核心功能

#### 1. 用户画像构建
```typescript
interface UserProfile {
  userId: string;
  preferences: {
    travelStyle: TravelStyle;
    budgetRange: BudgetRange;
    interests: Interest[];
    preferredDestinations: string[];
    preferredActivities: ActivityType[];
  };
  behavior: {
    searchHistory: SearchRecord[];
    clickHistory: ClickRecord[];
    bookingHistory: BookingRecord[];
    ratingHistory: RatingRecord[];
  };
  demographics: {
    age: number;
    gender: string;
    location: string;
    occupation: string;
  };
}

class UserProfileBuilder {
  async buildProfile(userId: string): Promise<UserProfile> {
    const [preferences, behavior, demographics] = await Promise.all([
      this.getUserPreferences(userId),
      this.getUserBehavior(userId),
      this.getUserDemographics(userId)
    ]);

    return {
      userId,
      preferences,
      behavior,
      demographics
    };
  }

  async updatePreferences(userId: string, newPreferences: Partial<UserPreferences>): Promise<void> {
    // 更新用户偏好
    await this.userRepository.updatePreferences(userId, newPreferences);
    
    // 重新计算推荐权重
    await this.recalculateRecommendationWeights(userId);
  }
}
```

#### 2. 景点推荐算法
```typescript
interface Attraction {
  id: string;
  name: string;
  location: Location;
  category: AttractionCategory;
  rating: number;
  price: number;
  openingHours: string;
  description: string;
  images: string[];
  tags: string[];
}

class AttractionRecommender {
  async recommendAttractions(
    location: string,
    userProfile: UserProfile,
    constraints: RecommendationConstraints
  ): Promise<Attraction[]> {
    // 1. 基于内容的过滤
    const contentBased = await this.contentBasedFiltering(location, userProfile);
    
    // 2. 协同过滤
    const collaborative = await this.collaborativeFiltering(location, userProfile);
    
    // 3. 混合推荐
    const hybrid = this.hybridRecommendation(contentBased, collaborative);
    
    // 4. 应用约束条件
    const filtered = this.applyConstraints(hybrid, constraints);
    
    // 5. 排序和返回
    return this.rankRecommendations(filtered, userProfile);
  }

  private async contentBasedFiltering(
    location: string,
    userProfile: UserProfile
  ): Promise<Attraction[]> {
    const attractions = await this.getAttractionsByLocation(location);
    
    return attractions.filter(attraction => {
      // 基于用户兴趣匹配
      const interestMatch = this.calculateInterestMatch(attraction, userProfile.preferences.interests);
      
      // 基于预算匹配
      const budgetMatch = attraction.price <= userProfile.preferences.budgetRange.max;
      
      // 基于旅行风格匹配
      const styleMatch = this.calculateStyleMatch(attraction, userProfile.preferences.travelStyle);
      
      return interestMatch > 0.6 && budgetMatch && styleMatch > 0.5;
    });
  }

  private async collaborativeFiltering(
    location: string,
    userProfile: UserProfile
  ): Promise<Attraction[]> {
    // 找到相似用户
    const similarUsers = await this.findSimilarUsers(userProfile);
    
    // 获取相似用户喜欢的景点
    const recommendations = new Map<string, number>();
    
    for (const similarUser of similarUsers) {
      const userRatings = await this.getUserRatings(similarUser.userId);
      const similarity = similarUser.similarity;
      
      for (const rating of userRatings) {
        if (rating.location === location && rating.rating >= 4) {
          const currentScore = recommendations.get(rating.attractionId) || 0;
          recommendations.set(rating.attractionId, currentScore + similarity * rating.rating);
        }
      }
    }
    
    // 获取推荐景点详情
    const attractionIds = Array.from(recommendations.keys())
      .sort((a, b) => recommendations.get(b)! - recommendations.get(a)!)
      .slice(0, 20);
    
    return await this.getAttractionsByIds(attractionIds);
  }
}
```

#### 3. 酒店推荐算法
```typescript
interface Hotel {
  id: string;
  name: string;
  location: Location;
  stars: number;
  price: number;
  amenities: string[];
  rating: number;
  reviews: number;
  images: string[];
  description: string;
}

class HotelRecommender {
  async recommendHotels(
    location: string,
    dates: DateRange,
    budget: BudgetRange,
    userProfile: UserProfile
  ): Promise<Hotel[]> {
    // 1. 获取可用酒店
    const availableHotels = await this.getAvailableHotels(location, dates);
    
    // 2. 预算过滤
    const budgetFiltered = availableHotels.filter(
      hotel => hotel.price >= budget.min && hotel.price <= budget.max
    );
    
    // 3. 个性化推荐
    const personalized = await this.personalizeRecommendations(budgetFiltered, userProfile);
    
    // 4. 评分排序
    return this.rankHotels(personalized, userProfile);
  }

  private async personalizeRecommendations(
    hotels: Hotel[],
    userProfile: UserProfile
  ): Promise<Hotel[]> {
    return hotels.map(hotel => ({
      ...hotel,
      personalizedScore: this.calculatePersonalizedScore(hotel, userProfile)
    })).sort((a, b) => b.personalizedScore - a.personalizedScore);
  }

  private calculatePersonalizedScore(hotel: Hotel, userProfile: UserProfile): number {
    let score = hotel.rating;
    
    // 基于用户偏好的调整
    if (userProfile.preferences.travelStyle === TravelStyle.LUXURY && hotel.stars >= 4) {
      score += 0.5;
    }
    
    if (userProfile.preferences.travelStyle === TravelStyle.BUDGET && hotel.price < 300) {
      score += 0.3;
    }
    
    // 基于历史行为的调整
    const userHistory = userProfile.behavior.bookingHistory;
    const similarHotels = userHistory.filter(booking => 
      Math.abs(booking.hotel.price - hotel.price) < 100
    );
    
    if (similarHotels.length > 0) {
      const avgRating = similarHotels.reduce((sum, booking) => sum + booking.rating, 0) / similarHotels.length;
      score += (avgRating - 3) * 0.2;
    }
    
    return score;
  }
}
```

## 💰 预算管理模块

### 模块概述
智能预算管理模块，提供费用估算、预算分析、成本优化建议等功能。

### 核心功能

#### 1. 费用估算器
```typescript
interface CostEstimate {
  category: CostCategory;
  amount: number;
  currency: string;
  breakdown: CostBreakdown[];
  confidence: number;
}

interface CostBreakdown {
  item: string;
  amount: number;
  unit: string;
  quantity: number;
  notes?: string;
}

class CostEstimator {
  async estimateTransportationCost(
    route: Route,
    mode: TransportMode,
    passengers: number
  ): Promise<CostEstimate> {
    const baseCost = this.getBaseTransportCost(route, mode);
    const distanceMultiplier = this.getDistanceMultiplier(route.distance);
    const modeMultiplier = this.getModeMultiplier(mode);
    
    const totalCost = baseCost * distanceMultiplier * modeMultiplier * passengers;
    
    return {
      category: CostCategory.TRANSPORTATION,
      amount: totalCost,
      currency: 'CNY',
      breakdown: [
        {
          item: `${mode}费用`,
          amount: totalCost,
          unit: '元',
          quantity: passengers,
          notes: `距离: ${route.distance / 1000}km`
        }
      ],
      confidence: 0.85
    };
  }

  async estimateAccommodationCost(
    hotels: Hotel[],
    duration: number,
    guests: number
  ): Promise<CostEstimate> {
    const totalCost = hotels.reduce((sum, hotel) => {
      return sum + hotel.price * duration * Math.ceil(guests / 2);
    }, 0);
    
    return {
      category: CostCategory.ACCOMMODATION,
      amount: totalCost,
      currency: 'CNY',
      breakdown: hotels.map(hotel => ({
        item: hotel.name,
        amount: hotel.price * duration * Math.ceil(guests / 2),
        unit: '元',
        quantity: duration,
        notes: `${hotel.stars}星级酒店`
      })),
      confidence: 0.9
    };
  }

  async estimateFoodCost(
    duration: number,
    guests: number,
    preferences: FoodPreferences
  ): Promise<CostEstimate> {
    const dailyCost = this.getDailyFoodCost(preferences);
    const totalCost = dailyCost * duration * guests;
    
    return {
      category: CostCategory.FOOD,
      amount: totalCost,
      currency: 'CNY',
      breakdown: [
        {
          item: '餐饮费用',
          amount: totalCost,
          unit: '元',
          quantity: duration * guests,
          notes: `每人每天${dailyCost}元`
        }
      ],
      confidence: 0.8
    };
  }
}
```

#### 2. 预算分析器
```typescript
interface BudgetAnalysis {
  totalBudget: number;
  breakdown: CostBreakdown[];
  efficiency: BudgetEfficiency;
  recommendations: BudgetRecommendation[];
  riskLevel: RiskLevel;
}

interface BudgetEfficiency {
  score: number; // 0-100
  category: 'excellent' | 'good' | 'fair' | 'poor';
  factors: EfficiencyFactor[];
}

class BudgetAnalyzer {
  analyzeBudget(itinerary: Itinerary, userBudget: number): BudgetAnalysis {
    const totalCost = this.calculateTotalCost(itinerary);
    const efficiency = this.calculateEfficiency(totalCost, userBudget);
    const recommendations = this.generateRecommendations(itinerary, totalCost, userBudget);
    const riskLevel = this.assessRiskLevel(totalCost, userBudget);
    
    return {
      totalBudget: totalCost,
      breakdown: this.getCostBreakdown(itinerary),
      efficiency,
      recommendations,
      riskLevel
    };
  }

  private calculateEfficiency(totalCost: number, userBudget: number): BudgetEfficiency {
    const ratio = totalCost / userBudget;
    let score: number;
    let category: BudgetEfficiency['category'];
    
    if (ratio <= 0.8) {
      score = 90 + (0.8 - ratio) * 50;
      category = 'excellent';
    } else if (ratio <= 1.0) {
      score = 70 + (1.0 - ratio) * 100;
      category = 'good';
    } else if (ratio <= 1.2) {
      score = 50 + (1.2 - ratio) * 100;
      category = 'fair';
    } else {
      score = Math.max(0, 50 - (ratio - 1.2) * 100);
      category = 'poor';
    }
    
    return {
      score: Math.round(score),
      category,
      factors: this.identifyEfficiencyFactors(totalCost, userBudget)
    };
  }

  private generateRecommendations(
    itinerary: Itinerary,
    totalCost: number,
    userBudget: number
  ): BudgetRecommendation[] {
    const recommendations: BudgetRecommendation[] = [];
    
    if (totalCost > userBudget) {
      // 超预算建议
      const overspend = totalCost - userBudget;
      
      if (itinerary.accommodation && itinerary.accommodation.cost > userBudget * 0.4) {
        recommendations.push({
          type: 'reduce_accommodation',
          description: `考虑选择更经济的住宿，可节省约${Math.round(overspend * 0.3)}元`,
          potentialSavings: overspend * 0.3,
          priority: 'high'
        });
      }
      
      if (itinerary.transportation && itinerary.transportation.cost > userBudget * 0.3) {
        recommendations.push({
          type: 'optimize_transport',
          description: `优化交通方式，可节省约${Math.round(overspend * 0.2)}元`,
          potentialSavings: overspend * 0.2,
          priority: 'medium'
        });
      }
    } else {
      // 预算充足建议
      const remaining = userBudget - totalCost;
      
      if (remaining > userBudget * 0.2) {
        recommendations.push({
          type: 'upgrade_experience',
          description: `可以考虑升级住宿或增加特色体验，预算充足`,
          potentialSavings: 0,
          priority: 'low'
        });
      }
    }
    
    return recommendations;
  }
}
```

---

**文档版本**: v1.0  
**最后更新**: 2024年12月  
**维护者**: 功能设计团队 